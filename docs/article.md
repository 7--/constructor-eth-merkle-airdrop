# Merkle airdrop

## Введение

За годы, проведенные в интернете я научился ненавидеть спам и ценить хорошие алгоритмы и красивые решения инженерных задач. В данной статье я расскажу как хороший алгоритм позволяет решить разом несколько проблем, присущих смарт-контрактам, которые оперируют большими списками адресов пользователей. Дело в том, что положить в контракт список даже из нескольких тысяч адресов и позволить этому набору адресов что-то делать в контракте напрямую не получится. В блокчйне экономится каждый байт и такие объёмы попросту не получится положить в блокчейн - это слишком дорого. Для решения задачи нам необходимо в коде контракта определить, принадлежит ли данный адрес списку "белых" адресов, и, если да, позволить сделать нужное действие. Предлагаемый вариант решения позволяет довольно просто решить эту проблему, держа в контракте всего одно число, и отдав клиенту обязанность доказать, что данный адрес находится в "белом" списке. Алгоритм Меркла, блестящего криптографа, широко используется в практически любом децентрализованном софте для обеспечения целостности наборов данных.

## Airdrop и ACL
Есть такая практика - выпустить свой токен и разослать его небольшие количества по дестякам тысяч адресов, у которых на балансе есть, для примера, "хотя бы 1 ETH". Такой спам, крайне популярный сейчас для продвижения собственных токенов, я люто ненавижу, ибо мне крайне не нравится появление на моем балансе чьих-то неведомых токенов. Тем не менее, проектам это нужно, и заказы на airdrop крайне популярны. Делается это обычно по старинке, вот так (я буду на примере Ethereum, но годятся и другие блокчейны с контрактами, EOS, например):

 - парсят блокчейн и находят много адресов по заданным критериям
 - создают адрес, на котором хранится достаточно токенов для рассылки всем из списка, либо предусматривают в контракте токена возможность создавать (mint-ить) нужное количество токенов заданному адресу (при отправке транзакции со специального привилегированного адреса)
 - кладут на этот адрес достаточно эфира, чтобы хватило на оплату комиссии за каждую отправку токенов пользователю
 - запускают скрипт рассылки, который перебирает адреса и для каждого создает транзакцию, переводящую (или mint-ящую) токены заданному адресу

Т.е. это просто проход по куче адресов и рассылка токенов каждому. В децентразлизованных система, такая "push" стратегия обычно довольно хромая, ибо стоит дорого, порождает дыры в безопасности и вообще - это спам. Если поподробнее про недостатки, то это:

  - на комиссии уходит много cредств (чем больше адресов, тем больше комиссия). Кроме того, в момент рассылки комиссия может расти, т.к. растет нагрузка на сеть, стоимость транзакции растет тоже
  - рассылка требует написания скрипта, который будет слать транзакции, а в скрипте зашит секретный ключ, который дает доступ к куче токенов
  - надо эту рассылку еще запрограммировать и уметь продолжить с места, где все сломалось

При этом есть решение гораздо проще, которое, как принято в децентрализованных сетях, большую часть работы отдает клиенту. Это контроль доступа с использованием дерева Меркла - структуры данных крайне удобной для того, чтобы хранить в контракте лишь одно число фиксированного размера (merkleRoot), которое хранит в себе информацию обо всех включенных в дерево данных (об огромном списке адресов получателей, например). Никакого волшебства здесь нет, ибо информацию, доказывающую, что адрес присутствует в списке разрешенных, клиент предоставляет самостоятельно, делая относительно объемные вычисления, и избавляя контракт от необходимости просмотра огромного списка адресов. Про дерево Меркла вы должны знать, если интересуетесь криптой, а если нет - обязательно прочитайте, эта структура крайне полезна для множества задач.

Я еще обмолвился словом "ACL", термин из файловых систем, ака "Access Control List" - это способ указания прав на некоторый объект в виде списка аккаутов и типов доступа к объекту. Я привел это термин, чтобы показать, что этот алгоритм годится для создания огромных ACL, которые позволяют предоставить доступ к некоторой функции контракта миллионам аккаунтов, записав в контракт единственное число для проверки принадлежности аккаунта к списку.

Ну а мы будем рассматривать схему с airdrop, т.к. она сейчас крайне востребована заказчиками, и является простым и демонстративным примером смарт-контрактов с большими ACL-ями.

## Схема DApp-a

Надеюсь, вы уже в курсе что такое смарт-контракт, в том числе и контракт токена, и понимаете как он работает. Напомню ленивым, что смарт-контракт сначала деплоится в сеть Ethereum, после чего получает свой собственный адрес и баланс в сети, а далее принимает и процессит внутри себя входящие транзакции.

В схеме merkle-airdrop токены не рассылаются по адресам, а пользователи сами "требуют" свои токены, отправляя транзакции в контракт и оплачивая комиссию. Секрет в том, что в транзакцию пользователи доавляют данные, позволяющие контракту легко проверить, находятся ли они в "белом" списке адресов, причем сам список контракту помнить совершенно не обязательно. Сам контракт при этом является крайне экономным, ему необходимо всего лишь <b>одно</b>(!) число для списка адресов <b>любого</b>(!) размера - именно в этом суть этого отличного алгоритма. А еще такой контракт крайне прост в запуске, после запуска не требует вообще никакой поддержки, и, за счет этой простоты, еще и крайне безопасен в использовании. Но об этих моментах чуть позже.

### Contract

Вот как приблизительно работает вся схема с контрактом merkle-airdrop:

  - в сеть выкладывается (или уже присутствует там) контракт токена
  - создается список адресов, которым позволено "потребовать" свои токены. Список генерируется на основе анализа блокчейна, собирается на сайте, или иным способом
  - все адреса складируются в один довольно массивный файл, который заливается куда нибудь, и доступен публично по некоторому URL. Мы, например, кладем в IPFS, но можно использовать любой способ залить файл и прочитать его потом из клиентского браузера
  - на файл натравливается скрипт, который из всех содержащихся в нем адресов строит Merkle tree, и получает один единственный хеш - Merkle root. Этот root - главный параметр нашего контракта, который будет выдавать токены
  - контракт merkle-airdrop выкладывется в сеть. При выкладке он запоминает merkle root и адрес контракта-токена, чтобы он мог делать transfer этого токена получателям
  - на баланс контракта-airdrop-а кладется большое число токенов (обычным transfer-ом), достаточное чтобы выдать всем участникам списка
  - теперь у контракта-airdrop-а доступна снаружи функция "claim-tokens-by-merkle-proof", которая принимает на вход от пользвателя merkle-proof - доказательство того, что пользватель есть в том самом большом "белом" списке адресов. Если доказательство верное, то контракт выполняет transfer() со своего адреса и переводит пользователю токены


### Client
Вот что делает клиент (все операции проводятся клиентским JavaScript прямо в браузере):

  - находит себя в "белом" списке, который публично размещен по некоторому URL и убеждается, что имеет право на токены
  - строит из всех адресов в списке дерево Меркла, и из него получает тот самый merkle-proof, который представляет собой несколько чисел(хешей), их количество зависит от размера списка, но по сравнению с ним очень мало, например для ~100 000 адресов достаточно ~17 хешей (размер merkle-proof: log<sub>2</sub>N, где N - число элементов).
  - отправляет в контракт транзакцию, вызывающую "claim-tokens-by-merkle-proof" и отправляющую туда полученный merkle-proof. Контракту остается проверить proof (при помощи сохранённого mrekle-root) и сделать transfer() токенов, если proof верный
  - контракт запоминает кому он выдал токены, чтобы предотвратить повторную выдачу


  Общими словами merkle-proof можно описать как "путь, которым можно пройти от адреса пользователя по дереву Меркла до самого merkle-root". Это довольно серьезная вычислительная работа и лишние данные, которые мы таким образом вынесли из контракта, сэкономив самое дорогое в блокчйне - storage. Merkle-proof доказательство состоит из log<sub>2</sub>N хешей (с округлением вверх до целого). Каждый хеш - такого же размера как и merkle-root, который мы записали в контракт-airdrop. Т.е. для списка из 1024 адресов, пользователь должен предоставить 10 хешей, а для ~4 млрд адресов, всего 32 хеша. Именно в протоколе построения и предъявления доказательства и прячется основная "фишка" контракта - хранение минимального количества информации для определения принадлежности некоторых данных к очень большому списку. Причем, чем список больше, тем больше выигрыш.

  В реальности контракт дополняется еще и возможностью забрать неиспользованные токены, обновить merkle root и ввести ограничения по времени, например запретить выдачу токенов после некоторого времени. Контракт несложно дорабатывается для раздачи произвольного количества токенов каждому адресу, в этом случае в файле хранятся не просто адреса получателей, но и необходимые суммы токенов, и слегка дорабатывается функция для проверки merkle-proof, но общий алгоритм от этого почти не меняется.

  ## Преимущества и недостатки merkle-airdrop

  Давайте отдельно выделим преимущества и недостатки вышеуказанного метода по сравнению с традиионной рассылкой скриптом:

  - Плюсы:
    - транзакция, требующая токены, стоит мало газа, причем это число - <b>константа</b>, вне зависимости от размера "белого" списка
    - после запсука контракта он не требует ни малейшей поддержки, вся активность обеспечивается пользователями
    - позволяет работать со списками практически произвольного размера с минимальным расходованием storage блокчейна

  - Минусы:
    - надо куда-то выкладывать публичный список адресов
    - каждому клиенту необходимо просмотреть все адреса в "белом" списке и выполнить довольно ресурсоёмкий код


  В данном алгоритме нет никаких секретов, такой выигрыш по памяти контракта щедро "оплачен" работой кода на клиентской стороне по проверке принадлежности к списку. Такой подход крайне удачно демонстрирует различие моделей использования смарт-контрактов в сравнении с традиционными централизованными системами.

  Традиционная рассылка токенов скриптом в ответ может противопоставить лишь простую и понятную схему работы. А усилия программиста для запуска обычного airdrop-а в разы превышают усилия для выкладки merkle-airdrop контракта, запущенный скрипт надо мониторить, чтобы не отвалился посередине списка, чтобы у него не закончились средства на комиссии за транзакции, следить чтобы никто не украл ключ, которым скрипт подписывает транзакции. Плюс, если у вас есть файл с адресами, собственно программист вам и не нужен. Чтобы задеплоить такой контракт программистом быть необязательно, через публичные сервисы это делается крайне просто.  


  # Заключение

  Главное, гхм, "преимущество" традиционной рассылки токенов по списку то, что эта схема позволяет закинуть токенов даже тем, кто не желает этого. Есть и особые извращения, когда токенов можно разослать так мало, что биржа даже не позволяет делать с ними транзакции, и теперь юзеры вынужен наблюдать эти ошмётки на своих адресах не имея возможности от них избавиться. Проблема airdrop, когда компания сознательно раздает часть токенов системы в коммюнити, конечно крайне важна для развития проектов. Но такое решение - недружелюбное к пользователям и неэффективное. Да и вообще, смарт-контракты крайне тяготеют к концепции "pull", а не "push", в которой именно пользователи сети являются инициаторами и контролерами бизнес процессов, а истории, когда централизованно кто-то что-то навязывает десяткам тысяч пользователей, постепенно уходят в прошлое. Меркловых вам airdrop-ов...

